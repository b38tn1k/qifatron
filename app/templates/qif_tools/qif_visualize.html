<!-- qif_visualize.html -->
{% extends 'base/base.html' %}
{% block content %}


<div id="p5-container" style="width: 100%; height: 400px;">

    <!-- Load p5.js from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>

    <script>
        let qifData = null;
        let maxDepth = 6;  // how many levels to recurse
        let rootNode = null;

        // For panning & zooming:
        let offsetX = 0;
        let offsetY = 0;
        let scaleFactor = 1.0;
        let dragging = false;
        let prevMouseX, prevMouseY;

        function setup() {
            const container = document.getElementById("p5-container");
            // For demonstration, let's rely on offsetWidth/offsetHeight
            let w = window.innerWidth;
            let h = window.innerHeight;
            // let w = container.offsetWidth;
            // let h = container.offsetHeight;

            // Create the canvas at that size
            canvas = createCanvas(w, h);
            canvas.parent("p5-container");

            // Event listeners for panning
            canvas.mousePressed(() => {
                dragging = true;
                prevMouseX = mouseX;
                prevMouseY = mouseY;
            });
            canvas.mouseReleased(() => { dragging = false; });

            // Load the dictionary from /qif/dictxml/<filename>
            const path = "/qif/dictxml/" + "{{ filename }}";
            fetch(path)
                .then(response => response.json())
                .then(data => {
                    qifData = data;
                    // Build a node hierarchy
                    rootNode = buildHierarchy(qifData, "root", 0);
                })
                .catch(err => {
                    console.error("Error loading data:", err);
                });
        }

        function mouseWheel(event) {
            // Typically, a positive event.delta means user is scrolling down
            // (which might zoom out), and negative delta means scrolling up.
            let zoomAmount = 0.01;
            if (event.delta > 0) {
                // Zoom out
                scaleFactor *= (1 - zoomAmount);
            } else {
                // Zoom in
                scaleFactor *= (1 + zoomAmount);
            }

            // Returning false prevents the default browser behavior (e.g. page scroll).
            return false;
        }

        function draw() {
            if (dragging) {
                offsetX += (mouseX - prevMouseX);
                offsetY += (mouseY - prevMouseY);
                prevMouseX = mouseX;
                prevMouseY = mouseY;
            }

            background(240);
            translate(offsetX, offsetY);
            scale(scaleFactor);

            if (!rootNode) {
                fill(100);
                text("Loading data...", 10, 30);
                return;
            }

            // We'll place the root in the center, then do a recursive layout
            push();
            translate(width / 2 / scaleFactor, height / 2 / scaleFactor);
            drawNode(rootNode);
            pop();
        }

        // Build a node structure from the JSON, up to maxDepth
        function buildHierarchy(obj, key, depth) {
            // This function returns an object: { name, children: [], depth, ... }

            if (depth > maxDepth) {
                return {
                    name: key + " ... (max depth reached)",
                    depth: depth,
                    children: []
                };
            }

            let node = {
                name: key,
                depth: depth,
                children: []
            };

            // If it's an object, iterate its keys
            if (obj && typeof obj === "object" && !Array.isArray(obj)) {
                // We want to skip special keys like "_path"
                let keys = Object.keys(obj).filter(k => k !== "_path");
                for (let k of keys) {
                    let childVal = obj[k];
                    node.children.push(buildHierarchy(childVal, k, depth + 1));
                }
            } else if (Array.isArray(obj)) {
                // It's an array â€“ we can display each index
                // If too big, consider slicing
                for (let i = 0; i < obj.length; i++) {
                    node.children.push(buildHierarchy(obj[i], `[${i}]`, depth + 1));
                }
            } else {
                // It's a leaf (string, number, etc.)
                // We'll just store its value as the name
                node.name = key + ": " + String(obj).substring(0, 50); // limit size
                node.children = [];
            }

            return node;
        }

        // Visualize a node with a radial layout for children
        function drawNode(node) {
            // Node circle
            let colorFrom = color(150, 100, 255); // purple
            let colorTo = color(255, 150, 100); // orange
            let t = map(node.depth, 0, maxDepth, 0, 1);
            let nodeColor = lerpColor(colorFrom, colorTo, t);

            noStroke();
            fill(nodeColor);
            ellipse(0, 0, 40, 40);

            // name label
            fill(0);
            textAlign(CENTER, CENTER);
            textSize(10);
            text(node.name, 0, -25);

            if (node.children.length === 0) {
                return; // no children => no radial layout
            }

            let angleStep = TWO_PI / node.children.length;
            let radius = 100 + 100 * (maxDepth - node.depth + 1); // children further out with depth
            for (let i = 0; i < node.children.length; i++) {
                let angle = i * angleStep;

                // position for the child
                let cx = radius * cos(angle);
                let cy = radius * sin(angle);

                // Draw a line from this node to child
                stroke(80);
                line(0, 0, cx, cy);

                // push the matrix and draw child
                push();
                translate(cx, cy);
                drawNode(node.children[i]);
                pop();
            }
        }
    </script>
    {% endblock %}