<!-- qif_visualize.html -->
{% extends 'base/base.html' %}
{% block content %}

<div id="p5-container" style="width: 100%; height: 600px;">
    <script src="{{ url_for('static', filename='js/p5.js') }}"></script>
    <script>
        let qifData = null;
        let rootNode = null;
        let maxDepth = 20;

        // We'll store a list of all nodes so we can easily draw them 
        // and compute bounding boxes without recursion each time.
        let allNodes = [];

        // Pan/Zoom
        let offsetX = 0, offsetY = 0;
        let scaleFactor = 1.0;
        let dragging = false;
        let prevMouseX, prevMouseY;

        function setup() {
            const container = document.getElementById("p5-container");
            let w = window.innerWidth;
            let h = window.innerHeight;
            let canvas = createCanvas(w, h).parent("p5-container");

            // Basic panning
            canvas.mousePressed(() => {
                dragging = true;
                prevMouseX = mouseX;
                prevMouseY = mouseY;
            });
            canvas.mouseReleased(() => {
                dragging = false;
            });

            const path = "/qif/dictxml/" + "{{ filename }}";
            fetch(path)
                .then(res => res.json())
                .then(data => {
                    qifData = data;
                    // Build the hierarchical structure
                    rootNode = buildHierarchy(qifData, "root", 0);

                    // 1) Compute positions for each node in a radial layout
                    //    We'll define root at (0,0) 
                    computeLayout(rootNode, 0, 0, 0, TWO_PI, 0);

                    // 2) Compute bounding box of all nodes
                    let { minX, maxX, minY, maxY } = findBoundingBox(allNodes);

                    // 3) Compute a scaleFactor to fit entire bounding box in the canvas
                    let margin = 50;
                    let boxWidth = maxX - minX;
                    let boxHeight = maxY - minY;
                    let sx = (width - margin) / boxWidth;
                    let sy = (height - margin) / boxHeight;
                    scaleFactor = min(sx, sy);

                    // 4) Compute offset so bounding box is centered
                    let midX = (minX + maxX) / 2;
                    let midY = (minY + maxY) / 2;
                    offsetX = width / 2 - midX * scaleFactor;
                    offsetY = height / 2 - midY * scaleFactor;

                })
                .catch(err => {
                    console.error("Error fetching QIF data:", err);
                });
        }

        function draw() {
            if (dragging) {
                offsetX += (mouseX - prevMouseX);
                offsetY += (mouseY - prevMouseY);
                prevMouseX = mouseX;
                prevMouseY = mouseY;
            }

            // background(240);
            clear();

            push();
            translate(offsetX, offsetY);
            scale(scaleFactor);

            // Draw edges & nodes
            // We'll do a BFS or just store everything in allNodes.
            stroke(100);
            for (let node of allNodes) {
                // draw lines from node to its children
                for (let child of node.children) {
                    line(node.x, node.y, child.x, child.y);
                }
            }

            noStroke();
            for (let node of allNodes) {
                // color depends on node.depth
                let cFrom = color(150, 100, 255);
                let cTo = color(255, 150, 100);
                let t = map(node.depth, 0, maxDepth, 0, 1);
                fill(lerpColor(cFrom, cTo, t));
                ellipse(node.x, node.y, 40, 40);

                fill(0);
                textSize(20);
                textAlign(CENTER, CENTER);
                text(node.name, node.x, node.y - 25);
            }

            pop();
        }

        // Basic mouseWheel zoom
        function mouseWheel(event) {
            let zoomAmount = 0.001;
            if (event.delta > 0) {
                scaleFactor *= (1 - zoomAmount * abs(event.delta));
            } else {
                scaleFactor *= (1 + zoomAmount * abs(event.delta));
            }
            return false;
        }

        // Build a node hierarchy from the JSON
        function buildHierarchy(obj, key, depth) {
            if (depth > maxDepth) {
                return { name: key + " (max depth)", depth, children: [] };
            }
            let node = { name: key, depth, children: [] };
            if (obj && typeof obj === "object" && !Array.isArray(obj)) {
                let keys = Object.keys(obj).filter(k => k !== "_path");
                for (let k of keys) {
                    node.children.push(buildHierarchy(obj[k], k, depth + 1));
                }
            }
            else if (Array.isArray(obj)) {
                for (let i = 0; i < obj.length; i++) {
                    node.children.push(buildHierarchy(obj[i], `[${i}]`, depth + 1));
                }
            } else {
                node.name = `${key}: ${String(obj).substring(0, 50)}`;
            }
            return node;
        }

        /**
         * computeLayout(node, x, y, angleStart, angleEnd, depth)
         * 1) Assign node.x, node.y = (x,y)
         * 2) spread children in [angleStart..angleEnd] radius
         */
        function computeLayout(node, x, y, angleStart, angleEnd, depth) {
            // Set node coords
            node.x = x;
            node.y = y;
            node.depth = depth;

            // Keep a global list of nodes for easy bounding box & draw
            if (!node.children) node.children = [];
            allNodes.push(node);

            if (node.children.length === 0) {
                return;
            }
            
            let angleGap = (angleEnd - angleStart);
            let angleStep = angleGap / (node.children.length);

            let radius = 60 + (depth) * 60;
            let childAngle = angleStart;

            for (let c of node.children) {
                let cx = x + radius * cos(childAngle);
                let cy = y + radius * sin(childAngle);
                computeLayout(c, cx, cy, childAngle, childAngle + angleStep, depth + 1);
                childAngle += angleStep;
            }
        }

        // find the bounding box of all nodes (minX, maxX, minY, maxY)
        function findBoundingBox(nodes) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            for (let n of nodes) {
                if (n.x < minX) minX = n.x;
                if (n.x > maxX) maxX = n.x;
                if (n.y < minY) minY = n.y;
                if (n.y > maxY) maxY = n.y;
            }
            return { minX, maxX, minY, maxY };
        }

    </script>
</div>
{% endblock %}